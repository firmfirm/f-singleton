<link rel="import" href="../polymer/polymer.html">

<!--
`<f-singleton>` is a Polymer element that helps implementing singleton pattern declaratively.

Common use case is to provide shared state in your elements (e.g. for configuration).

Example:

    <f-singleton key="myKey" value="{{myValue}}"></f-singleton>
    <p>[[myValue]]</p>

@element f-singleton
@demo demo/index.html
-->

<script>

(function() {
  'use strict'
  let instances = [];
  let state = {};

  Polymer({
    is: 'f-singleton',
    properties: {
      /**
       * Every instance of `<f-singleton>` points to the same `data` object.
       * **Do not** use Polymer's two-way binding to set properties of `data`.
       * Instead, call methods on `<f-singleton>` element like this:
       *
       *     this.$$('f-singleton').set('data.prop', 'val')
       *
       * Or **(better)** use `key` and `value` properties.
       *
       * Supported methods are:
       *   - `set(path, value)`
       *   - `push(path, item)`
       *   - `notifyPath(path, value, fromAbove)`
       *
       * @default {}
       */
      data: {
        type: Object,
        readOnly: true,
        notify: true,
        value: () => state
      },

      /*
       * Property name to bind `value` to.
       *
       * e.g. `key="myKey"` would bind `value` to `data.myKey`
       *
       * NOTE: deep keys are not supported for now, so if you set key to
       * something like `myObj.myProp` it will **not work**.
       */
      key: {
        type: String,
        observer: '_keyChanged'
      },

      /*
       * Has value of `data[key]`. Can be used with a two-way binding.
       */
      value: {
        type: String,
        notify: true,
        observer: '_valueChanged'
      }
    },

    observers: [ '_dataChanged(data.*)' ],

    created: function() {
      var override = (originalFn, override) => (...args) => {
        originalFn.apply(this, args);
        if (args[0].split(".")[0] === "data") {
          override(args);
        }
      };

      this._originalNotifyPath = this.notifyPath;
      var notifyPathAll = (args) => this._invokeInstances(this._originalNotifyPath, args);

      this.set = override(this.set, notifyPathAll);
      this.notifyPath = override(this.notifyPath, notifyPathAll);

      this.push = override(this.push, (args) => {
        var path = args[0];
        var array = this.get(path);
        var pushed = Array.prototype.slice.call(args, 1);
        var splice = {
          type: 'splice',
          object: array,
          removed: [],
          addedCount: pushed.length,
          index: array.length - pushed.length
        };
        this._invokeInstances(this.notifySplices, [path, [splice]]);
      });
      instances.push(this);
    },

    detached: function() { instances.splice(instances.indexOf(this), 1); },

    _invokeInstances: function(fn, args) {
      for (var i = 0; i < instances.length; i++) {
        let instance = instances[i];
        if (instance !== this) {
          fn.apply(instance, args);
        }
      }
    },

    _keyChanged: function(key) {
      this.value = this.data[this.key];
    },

    _valueChanged: function(value) {
      if (!this.key) return;
      this.set('data.' + this.key, value);
    },

    _dataChanged: function(changeRecord) {
      if (!this.key) return;
      var path = 'data.' + this.key;
      if (changeRecord.path === path) {
        this.value = this.data[this.key];
      } else if (changeRecord.path.startsWith(path)) {
        var valuePath = changeRecord.path.replace(path, 'value');
        this._originalNotifyPath(valuePath, changeRecord.value);
      }
    }
  });

})();

</script>
